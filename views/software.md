# Software

I am a **very experienced** full-stack web developer. Here is some of my background. 

* 2000-2003 - studied Computer Science at [Israel's oldest private school](https://en.wikipedia.org/wiki/Hebrew_Reali_School). 

* 2003-2008 - Software Product Manager at 8200 (IDF). Some of my biggest projects were a corps-wide knowledge management framework and an in-house BI tool. Both were pretty awesome and won some IDF awards. 

* 2009-2012 - Continued studying Computer Science at the Hebrew University of Jerusalem; double-majored in Psychology. A lot of **Java, C, C++**. Puts hairs on your chest. Finished on Dean's List. Especially interested in computability theory.

* 2009-2012 - My first job was at Cisco, writing in **JavaScript and Python**. I often think that the language one 'grows up' on shapes their mental image of computation and the way they view software as a whole. Growing up on JS, dynamic typing just seems natural to me. As an extension, I am also a NoSQL evangelist. 

* After graduating (2012), I started work as a **front-end developer** at a security firm. This was back when the JS SPA revolution (soon to be known as "JS Framework Fatigue") was just beginning. Backbone was in vogue; Knockout, Knockback, Angular 1. React was soon to come out. Silverlight and Flash were just being quietly taken out back and shot. I still have an **"I<3JS"** t-shirt and wear it proudly. 

* Later, I found myself at **Fiverr, where I really made my bones**. Ruby, Rails, Sinatra, Microservices, DBs, Queues. Mostly a backend dev, my first year was on the team in charging of the order flow and the banking system; that was a lot of 3am wake-up calls and white hairs. When the actual business model is down, you better believe you're getting up and fixing it. And then you learn damn well how to make sure you won't need to be woken up again the next time. I also learned to love **Ruby**, which is by far my favorite language today. If you actually need to get anything done (this includes maintenance), **nothing beats the productivity and sheer joy of doing it in Ruby**. 

* After leaving Fiverr I did some freelance work, mostly backend APIs as well as NodeJS and Angular. It was during this period that I learned to really appreciate the awesomeness and expressiveness of **Ruby (on Sinatra) over Mongo, running on PAAS like Heroku**. I am a very fast developer in general, but using the above stack just felt like I was on a jet plane. Nothing took any time, it was amazing. There was no "but... it hurt later to maintain/performance-tune/whatever". It was just amazing. It still is. Blows Rails/Node/AWS/Microservices/SQL out of the water. As of today, THAT is my choice of stack for any e-commerce/social app. 

* **In early 2015 I co-founded [yes.no](https://yes.no), a crowd-interviewing social network / platform. As CTO**, it was an interesting exercise in testing many of my assumptions and opinions about development. As we grew, hired, and expanded into mobile applications, we (read: I) had to constantly make both technical calls as well as decisions balancing product-tech-time tradeoffs. That is HARD. I am proud to say I believe I/we did an excellent job, as we managed to build and maintain a full-scale social network with all the bells and whistles. The stack proved itself, as well as many other architectural decisions. (This was also a valuable experience in management (and recruiting and retaining engineers) and entrepreneurship, but those are tales for another time; we are here to talk about software). Wary of "JS Fatigue" and despite being an ex-Angular enthusiast (mainly from side projects), I went back to believing in server-side rendering and vanilla JS (+JQ). The stack at yes.no was, in a nutshell, vanilla/JQ JS over server-side rendering on Ruby/Sinatra over Mongo on Heroku. We used LOTS of AJAX of course, mostly utilizing views-over-the-wire (an architecture the latest Rails release espouses as well; Views-over-the-wire enable AJAX views as well as fastest time-to-first-content without replicating templates on both client and server). This stack proved to reliably enable very rapid development as well as maintenance, whereas the negatives (mostly slight performance hits) were minor in comparison. 

* Today I work as a [consultant](/consulting). 


I know what I "believe" in. Many software engineers annoyingly reiterate the cliche of "the right tool for the right job", but any good geek has played D&D and knows that you choose your weapons **before** the job/battle, and before you know what you will be up against. Indeed, to the educated craftsman, often your choice of tools **determines** what task you will be up against. 

So yeah. **Software is awesome**. 